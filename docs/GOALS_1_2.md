# Цели 1 и 2: Бесшовный HLS + точное «Сейчас играет»

## Цель 1: Стабильный бесшовный эфир через HLS

**Что сделано:**
- HLS — основной источник для плеера (предгенерированные сегменты, без обрывов)
- `/stream` — fallback при отсутствии HLS
- Nginx раздаёт `/hls/` из `uploads/hls/`

**Проверка на сервере:** `stream.m3u8` есть в `/opt/navo-radio/uploads/hls/2026-02-21/-2118074462485919144/`

**Если эфир не воспроизводится:**
1. Проверить `/api/diagnostics` — `hls_ready: true`
2. Убедиться, что HLS сгенерирован для сегодняшней даты
3. При изменении расписания — перезапустить генерацию HLS (админка → Эфир → «Сгенерировать HLS»)

---

## Цель 2: Точное совпадение названия с воспроизведением

**Проблема:** `metadata.json` возвращал 404 — файл отсутствовал в старых HLS-директориях.

**Решение:**
1. **API fallback** — `GET /api/broadcast/playlist-metadata?d=YYYY-MM-DD` возвращает `{tracks: [{start, end, title}]}` из БД
2. Плеер: сначала запрос `metadata.json`, при 404 — запрос к API
3. Источник данных — SQL (BroadcastItem + metadata_json, get_entity_meta)

**Источник истины:** SQL (расписание, названия). `metadata.json` — кэш для HLS. API — fallback, когда кэша нет.

---

## JSON vs SQL — когда что использовать

| Данные | Где хранить | Зачем |
|--------|-------------|-------|
| Расписание эфира | **SQL** (BroadcastItem) | Редактирование, версионирование, связи с сущностями |
| Названия треков | **SQL** (metadata_json в BroadcastItem, Song, News…) | Один источник истины |
| metadata.json | **Файл** (при генерации HLS) | Быстрый доступ, привязка к позиции в потоке |
| API playlist-metadata | **Генерируется из SQL** | Fallback при 404 metadata.json |

**Вывод:** SQL — основной источник. JSON-файлы — производные для оптимизации. API может отдавать данные из SQL в любой момент.

---

## Что проверить после деплоя

1. https://navoradio.com/ — Play → эфир воспроизводится
2. «Сейчас играет» внизу страницы совпадает с тем, что звучит
3. При 404 metadata.json — используется API, отображение должно работать
